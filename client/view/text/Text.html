<div class="container">
	<div class="header">
		<StateLink state="main.book-selection" className="bigger-link">Â« Books</StateLink>
	</div>

	<h1 class="book-name-header">
		{{bookName}}
	</h1>


	<div class="text-container" ref:textContainer>
		{{#each bookSectionsWithChapterAndVerseMarkers as section}}
			{{#if section.type === 'header'}}
				<h3>{{section.value}}</h3>
			{{elseif section.type === 'break'}}
				<hr>
			{{elseif section.type === 'paragraph'}}
				<p>
					<TextSectionChildren children="{{section.children}}" />
				</p>
			{{elseif section.type === 'stanza'}}
				<blockquote>
					<TextSectionChildren children="{{section.children}}" />
				</blockquote>
			{{else}}
				<h1>WAT BROKEN</h1>
			{{/if}}
		{{/each}}
	</div>
</div>

<RightMarginChapterNumbers :chapterNumbers :currentChapter />

<style>
@import 'mixins';
@import 'gutter';

.book-name-header {
	text-align: center;
}

.container {
	@include container-side-padding;
	@include container-vertical-padding;
}

.bigger-link {
	font-size: x-large;
	font-family: sans-serif;
}

.text-container {
	max-width: 600px;
	margin-left: $gutterSize;
	margin-right: $gutterSize;
}
</style>

<script>
import StateLink from 'component/StateLink.html'
import { getChapterNumberId } from 'lib/get-id.js'

import TextSectionChildren from './TextSectionChildren.html'
import RightMarginChapterNumbers from './RightMarginChapterNumbers.html'

const flatMap = (ary, fn) => ary.reduce(
	(acc, element, index) => [ ...acc, ...fn(element, index) ],
	[]
)

function observeIntersectionsWithTopOfViewport(elements, cb) {
	const viewportTopObserver = new IntersectionObserver(entries => {
		const intersectingEntries = entries.filter(entry => entry.isIntersecting)
		cb(intersectingEntries)
	}, {
		rootMargin: '0px 0px -95%',
		threshold: 0.1
	})

	Array.from(elements).forEach(element => viewportTopObserver.observe(element))

	return viewportTopObserver
}

export default {
	data() {
		return {
			bookName: null,
			bookSections: null,
			currentChapter: null
		}
	},
	oncreate() {
		const textElements = this.refs.textContainer.querySelectorAll('.verse-text')
		const viewportTopObserver = observeIntersectionsWithTopOfViewport(textElements, entries => {
			const currentChapter = entries.reduce((currentChapter, entry) => {
				const data = entry.target.dataset
				const entryChapter = parseInt(data.chapterNumber, 10)

				return Math.max(currentChapter, entryChapter)
			}, 0)

			currentChapter && this.set({ currentChapter })
		})

		this.viewportTopObserver = viewportTopObserver
	},
	ondestroy() {
		this.viewportTopObserver.disconnect()
	},
	computed: {
		bookSectionsWithChapterAndVerseMarkers: bookSections => {
			let lastChapterNumber = null
			let lastVerseNumber = null

			return bookSections.map(section => Object.assign({}, section, {
				children: section.children && flatMap(section.children, chunk => {
					const { chapterNumber, verseNumber } = chunk
					const itemsToReturn = []

					if (chapterNumber && chapterNumber !== lastChapterNumber) {
						itemsToReturn.push({
							type: 'chapter number',
							value: chapterNumber
						})
						lastChapterNumber = chapterNumber
					}

					if (verseNumber && verseNumber !== lastVerseNumber) {
						itemsToReturn.push({
							type: 'verse number',
							value: verseNumber,
							chapterNumber,
						})
						lastVerseNumber = verseNumber
					}

					itemsToReturn.push(chunk)

					return itemsToReturn
				})
			}))
		},
		chapterNumbers: bookSectionsWithChapterAndVerseMarkers => flatMap(bookSectionsWithChapterAndVerseMarkers,
			({ children }) => children
				? children
					.filter(({ type }) => type === 'chapter number')
					.map(({ value }) => value)
				: []
		),
	},
	helpers: {
		getChapterNumberId
	},
	components: {
		StateLink,
		RightMarginChapterNumbers,
		TextSectionChildren
	}
}
</script>

<div class="background-border">
	<form on:submit="onsubmit(event)">
		<input
			type="text"
			ref:input
			bind:value="inputValue"
			on:blur="lostInputFocus(event)"
			on:keydown="onkeydown(event)"
		>
	</form>
</div>

<style>
@import 'variables';

.background-border {
	padding: 8px;
	background-color: $gray;
	border-radius: 4px;
}

input {
	font-size: 32px;
	border-radius: 4px;
	padding: 4px 8px;
}
</style>

<script>
import nextTick from 'iso-next-tick'

import getTargetStateFromReference from 'lib/get-target-state-from-reference.js'
import equalEnough from 'lib/equal-enough'

const code_escape = 27
const isEscape = event => event.key === 'Escape' || event.keyCode === code_escape

function navigationState(component) {
	let haveNavigated = false
	let lastState = null
	let lastParams = null
	let lastAnchor = null

	const setNavigating = navigating => component.set({ navigating })

	component.observe('matchingReference', target => {
		component.rememberFocus()

		if (target) {
			const mediator = component.get('mediator')
			const { anchor, stateName, params } = target

			const samePage = lastState === stateName && equalEnough(lastParams, params)

			if (!samePage) {
				if (anchor) {
					mediator.callSync('setAnchorAfterStateTransition', stateName, params, anchor)
				}

				setNavigating(true)

				mediator.callSync('stateGo', stateName, params, {
					replace: haveNavigated
				})

				mediator.call('afterStateTransitionTo', stateName, params).then(() => {
					nextTick(() => setNavigating(false))
				})
			} else if (anchor && anchor !== lastAnchor && document.getElementById(anchor)) {
				setNavigating(true)
				window.history.replaceState({}, '', `#${anchor}`)
				const element = document.getElementById(anchor)
				element.scrollIntoView(true)
				setNavigating(false)
			}

			lastState = stateName
			lastParams = params
			lastAnchor = anchor
			haveNavigated = true
		}
	})
}

export default {
	oncreate() {
		this.refs.input.focus()

		navigationState(this)
	},
	data() {
		return {
			inputValue: '',
			focusPosition: null,
		}
	},
	computed: {
		matchingReference: inputValue => getTargetStateFromReference(inputValue)
	},
	methods: {
		rememberFocus() {
			this.set({
				focusPosition: {
					selectionStart: this.refs.input.selectionStart,
					selectionEnd: this.refs.input.selectionEnd,
					selectionDirection: this.refs.input.selectionDirection,
				}
			})
		},
		lostInputFocus(event) {
			const target = event.explicitOriginalTarget || document.activeElement
			const input = this.refs.input

			const focusPosition = this.get('focusPosition')
			if (input !== target && this.get('navigating') && focusPosition) {
				const { selectionStart, selectionEnd, selectionDirection } = focusPosition

				input.setSelectionRange(selectionStart, selectionEnd, selectionDirection)
				input.focus()
			} else {
				this.set({
					show: false
				})
			}
		},
		onsubmit(event) {
			this.set({
				show: false
			})

			event.preventDefault()
		},
		onkeydown(event) {
			if (isEscape(event)) {
				this.set({
					show: false
				})
				window.history.back()
			}
		}
	}
}
</script>
